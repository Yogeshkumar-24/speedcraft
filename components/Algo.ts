export const Algo = [
    "class BinarySearch { ↵ int search(int[] arr, int x) { ↵ int l = 0, r = arr.length - 1; ↵ while (l <= r) { ↵ int m = l + (r - l) / 2; ↵ if (arr[m] == x) return m; ↵ if (arr[m] < x) l = m + 1; ↵ else r = m - 1; ↵ } ↵ return -1; ↵ } ↵ }",
    
    "class MergeSort { ↵ void merge(int[] arr, int l, int m, int r) { ↵ int n1 = m - l + 1, n2 = r - m; ↵ int[] L = new int[n1], R = new int[n2]; ↵ System.arraycopy(arr, l, L, 0, n1); ↵ System.arraycopy(arr, m + 1, R, 0, n2); ↵ int i = 0, j = 0, k = l; ↵ while (i < n1 && j < n2) ↵ arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++]; ↵ while (i < n1) arr[k++] = L[i++]; ↵ while (j < n2) arr[k++] = R[j++]; ↵ } ↵ void sort(int[] arr, int l, int r) { ↵ if (l < r) { ↵ int m = l + (r - l) / 2; ↵ sort(arr, l, m); ↵ sort(arr, m + 1, r); ↵ merge(arr, l, m, r); ↵ } ↵ } ↵ }",

    "class QuickSort { ↵ int partition(int[] arr, int low, int high) { ↵ int pivot = arr[high], i = low - 1; ↵ for (int j = low; j < high; j++) { ↵ if (arr[j] < pivot) { ↵ i++; ↵ int temp = arr[i]; ↵ arr[i] = arr[j]; ↵ arr[j] = temp; ↵ } ↵ } ↵ int temp = arr[i + 1]; ↵ arr[i + 1] = arr[high]; ↵ arr[high] = temp; ↵ return i + 1; ↵ } ↵ void sort(int[] arr, int low, int high) { ↵ if (low < high) { ↵ int pi = partition(arr, low, high); ↵ sort(arr, low, pi - 1); ↵ sort(arr, pi + 1, high); ↵ } ↵ } ↵ }",

    "class Dijkstra { ↵ void shortestPath(int[][] graph, int src) { ↵ int V = graph.length; ↵ int[] dist = new int[V]; ↵ boolean[] sptSet = new boolean[V]; ↵ Arrays.fill(dist, Integer.MAX_VALUE); ↵ dist[src] = 0; ↵ for (int count = 0; count < V - 1; count++) { ↵ int u = -1, min = Integer.MAX_VALUE; ↵ for (int v = 0; v < V; v++) ↵ if (!sptSet[v] && dist[v] < min) { ↵ min = dist[v]; ↵ u = v; ↵ } ↵ sptSet[u] = true; ↵ for (int v = 0; v < V; v++) ↵ if (!sptSet[v] && graph[u][v] != 0 && dist[u] != Integer.MAX_VALUE && dist[u] + graph[u][v] < dist[v]) ↵ dist[v] = dist[u] + graph[u][v]; ↵ } ↵ } ↵ }",

    "class Knapsack { ↵ int knapSack(int W, int[] wt, int[] val, int n) { ↵ int[][] dp = new int[n + 1][W + 1]; ↵ for (int i = 0; i <= n; i++) { ↵ for (int w = 0; w <= W; w++) { ↵ if (i == 0 || w == 0) ↵ dp[i][w] = 0; ↵ else if (wt[i - 1] <= w) ↵ dp[i][w] = Math.max(val[i - 1] + dp[i - 1][w - wt[i - 1]], dp[i - 1][w]); ↵ else ↵ dp[i][w] = dp[i - 1][w]; ↵ } ↵ } ↵ return dp[n][W]; ↵ } ↵ }",

    "class LCS { ↵ int lcs(String X, String Y) { ↵ int m = X.length(), n = Y.length(); ↵ int[][] dp = new int[m + 1][n + 1]; ↵ for (int i = 1; i <= m; i++) { ↵ for (int j = 1; j <= n; j++) { ↵ if (X.charAt(i - 1) == Y.charAt(j - 1)) ↵ dp[i][j] = dp[i - 1][j - 1] + 1; ↵ else ↵ dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); ↵ } ↵ } ↵ return dp[m][n]; ↵ } ↵ }",

    "class UnionFind { ↵ int[] parent, rank; ↵ UnionFind(int n) { ↵ parent = new int[n]; ↵ rank = new int[n]; ↵ for (int i = 0; i < n; i++) ↵ parent[i] = i; ↵ } ↵ int find(int x) { ↵ if (parent[x] != x) ↵ parent[x] = find(parent[x]); ↵ return parent[x]; ↵ } ↵ void union(int x, int y) { ↵ int rootX = find(x), rootY = find(y); ↵ if (rootX != rootY) { ↵ if (rank[rootX] > rank[rootY]) ↵ parent[rootY] = rootX; ↵ else if (rank[rootX] < rank[rootY]) ↵ parent[rootX] = rootY; ↵ else { ↵ parent[rootY] = rootX; ↵ rank[rootX]++; ↵ } ↵ } ↵ } ↵ }",

    "class TrieNode { ↵ TrieNode[] children = new TrieNode[26]; ↵ boolean isEndOfWord; ↵ } ↵ class Trie { ↵ TrieNode root = new TrieNode(); ↵ void insert(String key) { ↵ TrieNode p = root; ↵ for (char c : key.toCharArray()) { ↵ if (p.children[c - 'a'] == null) p.children[c - 'a'] = new TrieNode(); ↵ p = p.children[c - 'a']; ↵ } ↵ p.isEndOfWord = true; ↵ } ↵ boolean search(String key) { ↵ TrieNode p = root; ↵ for (char c : key.toCharArray()) { ↵ if (p.children[c - 'a'] == null) return false; ↵ p = p.children[c - 'a']; ↵ } ↵ return p.isEndOfWord; ↵ } ↵ }",

    "class FloydWarshall { ↵ void shortestPaths(int[][] graph) { ↵ int V = graph.length; ↵ int[][] dist = new int[V][V]; ↵ for (int i = 0; i < V; i++)↵ for (int j = 0; j < V; j++)↵ dist[i][j] = graph[i][j]; ↵ for (int k = 0; k < V; k++) { ↵ for (int i = 0; i < V; i++) { ↵ for (int j = 0; j < V; j++) { ↵ if (dist[i][k] != Integer.MAX_VALUE &&↵ dist[k][j] != Integer.MAX_VALUE &&↵ dist[i][k] + dist[k][j] < dist[i][j])↵ dist[i][j] = dist[i][k] + dist[k][j]; ↵ } ↵ } ↵ } ↵ } ↵ }",

    "class BellmanFord { ↵ void shortestPath(int[][] graph, int src) { ↵ int V = graph.length; ↵ int[] dist = new int[V]; ↵ Arrays.fill(dist, Integer.MAX_VALUE); ↵ dist[src] = 0; ↵ for (int i = 0; i < V - 1; i++) { ↵ for (int[] edge : graph) { ↵ int u = edge[0], v = edge[1], w = edge[2]; ↵ if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v])↵ dist[v] = dist[u] + w; ↵ } ↵ } ↵ } ↵ }",

    "class Kadane { ↵ int maxSubArray(int[] nums) { ↵ int maxSum = nums[0], currentSum = nums[0]; ↵ for (int i = 1; i < nums.length; i++) { ↵ currentSum = Math.max(nums[i], currentSum + nums[i]); ↵ maxSum = Math.max(maxSum, currentSum); ↵ } ↵ return maxSum; ↵ } ↵ }",
    
    "class KMP { ↵ void computeLPS(String pattern, int[] lps) { ↵ int len = 0, i = 1; ↵ while (i < pattern.length()) { ↵ if (pattern.charAt(i) == pattern.charAt(len)) { ↵ lps[i++] = ++len; ↵ } else { ↵ if (len != 0) len = lps[len - 1]; ↵ else lps[i++] = 0; ↵ } ↵ } ↵ } ↵ int search(String text, String pattern) { ↵ int M = pattern.length(), N = text.length(); ↵ int[] lps = new int[M]; ↵ computeLPS(pattern, lps); ↵ int i = 0, j = 0; ↵ while (i < N) { ↵ if (pattern.charAt(j) == text.charAt(i)) { ↵ i++; j++; ↵ if (j == M) return i - j; ↵ } else if (j > 0) j = lps[j - 1]; ↵ else i++; ↵ } ↵ return -1; ↵ } ↵ }",
    
];
